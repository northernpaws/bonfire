use std::{
    collections::HashSet,
    io::Bytes,
    path::{Path, PathBuf},
    str::FromStr,
};

use bonfire::proto::v0;
use color_eyre::eyre::eyre;
use log::info;
use prost::Message;
use prost_types::FileDescriptorSet;
use schemars::schema_for;

use mdbook_driver::MDBook;

fn main() -> color_eyre::Result<()> {
    let root_dir: PathBuf = "docs/".into();

    // Attempt to load the docs book.
    let mut md = MDBook::load(root_dir).map_err(|err| eyre!("failed to load book: {err}"))?;

    add_proto_sections_v0(&mut md)?;
    add_json_sections_v0(&mut md)?;

    // Attempt to build the book.
    md.build()
        .map_err(|err| eyre!("failed to build book: {err}"))?;

    Ok(())
}

fn add_proto_sections_v0(book: &mut MDBook) -> color_eyre::Result<()> {
    // Descriptor is generated by the build.rs script.
    let descriptor_bytes =
        include_bytes!(concat!(env!("OUT_DIR"), "/proto_file_descriptor_set.pb"));

    // Decode the protobuf file descriptor set.
    let file_descriptor_set = FileDescriptorSet::decode(&descriptor_bytes[..])
        .map_err(|err| eyre!("failed to parse file descriptor set as protobuf: {err}"))?;

    info!("found {} proto files", file_descriptor_set.file.len());

    // Extract the list of protobuf packages from the descriptors.
    let packages: HashSet<String> = file_descriptor_set
        .file
        .iter()
        .map(|f| f.package().to_string())
        .collect();

    Ok(())
}

fn add_json_sections_v0(book: &mut MDBook) -> color_eyre::Result<()> {
    // Schema of the JSON message used to send data
    // from the gateway server to the client.
    let gateway_server_event = schema_for!(v0::gateway_server_event::Event);

    // Schema of the JSON message used to send data
    // from the client to the gateway server.
    let gateway_client_event = schema_for!(v0::gateway_client_event::Event);

    Ok(())
}

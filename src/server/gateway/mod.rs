//! The client module provides the bulk of the client event
//! processing and communication channels functionality.
//!
//! For each connection for a client to the server,

use std::{
    collections::HashMap,
    hash::{self, Hasher},
    sync::{Arc, RwLock},
};

use chrono::Utc;
use log::info;
use snowflaked::Snowflake;
use tokio::sync::{broadcast, mpsc};
use tracing::{Instrument, info_span};

use crate::{
    proto::v0::{self, GatewayClientEvent, GatewayServerEvent},
    user::UserId,
};

/// Concrete type for client session ID's .
#[derive(PartialEq, Eq, Copy, Clone, Debug)]
pub struct SessionId(pub u64);

impl hash::Hash for SessionId {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u64(self.0);
    }
}

impl Snowflake for SessionId {
    fn from_parts(timestamp: u64, instance: u64, sequence: u64) -> Self {
        Self(u64::from_parts(timestamp, instance, sequence))
    }

    fn timestamp(&self) -> u64 {
        self.0.timestamp()
    }

    fn instance(&self) -> u64 {
        self.0.instance()
    }

    fn sequence(&self) -> u64 {
        self.0.sequence()
    }
}

/// Indicates the connection state of the client.
pub enum ConnectionState {
    Connected,
    Disconnected,
}

/// State of a connected client session.
pub struct Session {
    id: SessionId,

    // The user the session is authorized as.
    user: UserId,

    /// Indiciates the connection state of the client.
    state: ConnectionState,

    /// The identity transmitted by the client
    /// when it connected to the gateway.
    identity: v0::GatewayIdentify,

    /// Indicates when the client was last
    /// connected to the session in seconds.
    last_contact_s: i64,

    // Channels for sending server events to the session's client.
    server_event_sender: broadcast::Sender<GatewayServerEvent>,
    server_event_subscriber: broadcast::Receiver<GatewayServerEvent>,

    /// Ingests client events to the session worker.
    client_event_sender: mpsc::Sender<GatewayClientEvent>,
}

impl Session {
    /// Constructs a new client session.
    pub fn new(
        id: SessionId,
        user: UserId,
        state: ConnectionState,
        identity: v0::GatewayIdentify,
    ) -> Self {
        // Channel for sending events generated by
        // the server to it's associated client.
        let (server_event_sender, server_event_subscriber) = broadcast::channel(10);

        // Channel for ingesting events generated by a client.
        let (client_event_sender, client_event_receiver) = mpsc::channel(10);

        tracing::info!(
            session_id = ?id,
            user_ud = ?user,
            "starting client session worker");

        tokio::spawn(session_worker(client_event_receiver));

        Self {
            id,
            user,
            state,
            identity,
            last_contact_s: 0,

            server_event_sender,
            server_event_subscriber,

            client_event_sender,
        }
    }

    /// Returns the ID of the session.
    pub fn session_id(&self) -> SessionId {
        self.id
    }

    /// Updates the last-contacted time for the session.
    pub fn contacted(&mut self) {
        self.last_contact_s = Utc::now().timestamp();

        tracing::debug!(session = ?self.id, "updating client session with heartbeat");
    }

    /// Subscribe to session events.
    ///
    /// Used by the gateways to receive the events generated
    /// by the server to forward to the connected client.
    pub fn subscribe(&self) -> broadcast::Receiver<GatewayServerEvent> {
        self.server_event_subscriber.resubscribe()
    }

    /// Returns a sender for forwarding events generated
    /// by client endpoints to the server's session worker.
    pub fn client_event_sender(&self) -> mpsc::Sender<GatewayClientEvent> {
        self.client_event_sender.clone()
    }
}

/// Service for managing clients.
///
/// This maintains and manages client connection sessions.
pub struct GatewayService {
    id_generator: snowflaked::Generator,

    /// Active gateway client sessions.
    sessions: RwLock<HashMap<SessionId, Arc<RwLock<Session>>>>,
}

impl GatewayService {
    /// Construct a new instance of the client service.
    pub fn new() -> Self {
        Self {
            id_generator: snowflaked::Generator::new(0),
            sessions: RwLock::new(HashMap::new()),
        }
    }

    /// Creates a new client connection session.
    pub fn create_session(
        &mut self,
        user_id: UserId,
        identity: v0::GatewayIdentify,
    ) -> Arc<RwLock<Session>> {
        // Generate the ID for the new session.
        let id = self.id_generator.generate();

        // Construct the new session's state.
        let session = Arc::new(RwLock::new(Session::new(
            id,
            user_id,
            ConnectionState::Connected,
            identity,
        )));

        // Insert the session into the active session table.
        self.sessions
            .write()
            .unwrap()
            .insert(id, Arc::clone(&session));

        tracing::info!(id = ?id, "created new client session");

        session
    }

    /// Closes an open client session.
    pub fn close_session(&mut self, id: SessionId) {
        // Remove the session from the active session table.
        self.sessions.write().unwrap().remove(&id);

        tracing::info!(id = ?id, "closing client session");
    }
}

/// Worker task spawned for each client session.
async fn session_worker(mut client_event_receiver: mpsc::Receiver<GatewayClientEvent>) {
    loop {
        // Wait to receive the next event from the client.
        let Some(event) = client_event_receiver
            .recv()
            .instrument(info_span!("client_session_worker_recv"))
            .await
        else {
            tracing::info!("client session worker channel closed");

            break;
        };

        tracing::debug!(
            event = ?event,
            "session worker received event from client");
    }

    tracing::info!("client session worker exited");
}
